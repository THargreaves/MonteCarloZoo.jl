var documenterSearchIndex = {"docs":
[{"location":"index.html#MonteCarloZoo.jl","page":"Index","title":"MonteCarloZoo.jl","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Documentation for MonteCarloZoo.jl.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"MonteCarloZoo","category":"page"},{"location":"index.html#MonteCarloZoo","page":"Index","title":"MonteCarloZoo","text":"MonteCarloZoo\n\nA broad collection of Monte Carlo algorithms implemented in Julia.\n\n\n\n\n\n","category":"module"},{"location":"index.html#Module-Index","page":"Index","title":"Module Index","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Modules = [MonteCarloZoo]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"index.html#Detailed-API","page":"Index","title":"Detailed API","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Modules = [MonteCarloZoo]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"index.html#MonteCarloZoo.box_muller_transform_sampler-Tuple{Any}","page":"Index","title":"MonteCarloZoo.box_muller_transform_sampler","text":"box_muller_transform_sampler(N)\n\nPerform Box-Muller transform sampling to generate standard Normal samples.\n\nThe Box-Muller transform is a technique for generating independent, standard, normally distributed samples. It involves sampling from a polar coordinate system in which the angle of the sample is uniformly distrubition and the radius is distributed as textexp(tfrac12) (equivalent to chi^2_1). It can then be shown that the cartesian coordinates of these samples have independent standard normal distributions.\n\nThe full algorithm is given here:\n\nSample U_1 U_2 stackreltextiidsim textUnif(0 1)\nCompute Z_1 = sqrt-2 log U_1cos(2pi U_2), Z_2 = sqrt-2 log U_1sin(2pi U_2)\n\nArguments\n\nN::Integer: the number of samples to generate.\n\nExamples\n\n# 10 standard normal random variables\nsamples = box_muller_transform_sampler(10)\n\n\n\n\n\n","category":"method"},{"location":"index.html#MonteCarloZoo.inverse_transform_sampler-Tuple{Any, Any}","page":"Index","title":"MonteCarloZoo.inverse_transform_sampler","text":"inverse_transform_sampler(F_inv, N)\n\nPerform inverse transform sampling using a supplied inverse CDF.\n\nInverse transform sampling is based on the result that when U sim textUnif(0 1), X = F^-1(U) will be distributed according to the CDF F. For non-decreasing CDFs we can replace F^-1 with F's generalised inverse F^-(u) = infx  F(x)  u and use the same method.\n\nArguments\n\nF_inv::Function: the inverse CDF of the target distrubition.\nN::Integer: the number of samples to generate.\n\nNotes\n\nBecause of the symmetry of a uniform random sample, one can replace 1-u in the inverse CDF with u.\n\nExamples\n\n# Sampling from an exponential distribution\nF_inv(u) = -log(u)  # using symmetry of U (see notes)\nN = 100\n\nsamples = inverse_transform_sampler(F_inv, N)\n\n\n\n\n\n","category":"method"},{"location":"index.html#MonteCarloZoo.rejection_sampler-NTuple{6, Any}","page":"Index","title":"MonteCarloZoo.rejection_sampler","text":"rejection_sampler(target_density, proposal_density, proposal_sampler,\n                  scale, iterations, dimension)\n\nPerform rejection sampling using a supplied target and proposal distribution.\n\nRejection sampling involves sampling from a target distribution f using a proposal distribution g which we are able to directly sample from. In order for the resulting samples to be distributed according to f we require that fracf(x)g(x) is bounded from above by some constant M (scale) for all x in the support of f.\n\nUnder these conditions, the rejection sampling algorithm given below will generate independent samples from f:\n\nSample X sim g\nAccept X with probability fracf(X)Mg(X)\n\nArguments\n\ntarget_density::Function: density function for the target distribution.\nproposal_density::Function: density function for the proposal distribution.\nproposal_sampler::Function: a function that generates samples from the   proposal distribution.\nscale::Real: a scaling constant that bounds the ratio of the target and   proposal density.\niterations::Integer: the number of samples to generate.\ndimension::Integer: the expected dimension of each sample.\n\nNotes\n\nNo checks are made to ensure that the scale constant is valid or that the  proposal sampler and density match. If these conditions are not met, the resulting samples will not be distributed according to the target density.\nThe expected acceptance rate for the sampler is the reciprocal of scale.\n\nExamples\n\n# Sampling from a standard normal distribution using Cauchy proposals\ntarget_density(x) = exp(-x^2 / 2) / sqrt(2π)\nproposal_density(x) = (1 + x^2) / π \nproposal_sampler() = tan(π * (rand() - 0.5))\nscale = sqrt(2π / ℯ)\niterations = 100\ndimension = 1\n\nsamples = rejection_sampler(\n    target_density, proposal_density, proposal_sampler,\n    scale, iterations, dimension\n)\n\n\n\n\n\n","category":"method"}]
}
